extern crate cryptoctf;

#[cfg(test)]
mod test {

    use cryptoctf::symmetric::aes::*;

    #[test]
    fn test_aes_ecb() {
        let k = vec![
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f,
            0x3c,
        ];

        let input: [u8; 16] = [
            0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07,
            0x34,
        ];

        let expected: [u8; 16] = [
            0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b,
            0x32,
        ];

        let mut aes = AES::new(&k, OperationMode::ECB);

        let encrypted = aes.encrypt(&input);
        assert_eq!(encrypted, expected);
        let decrypted = aes.decrypt(&encrypted);
        assert_eq!(input.to_vec(), decrypted);
    }

    #[test]
    fn test_aes_cbc() {

        let k = vec![
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f,
            0x3c,
        ];

        let input: [u8; 32] = [
            0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b,
            0x32,0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f,
            0x3c,
        ];

        let mut aes = AES::new(&k, OperationMode::CBC {iv: [0u8; 16]});
        let encrypted = aes.encrypt(&input);
        let decrypted = aes.decrypt(&encrypted);

        assert_eq!(decrypted, input);
    }

}
